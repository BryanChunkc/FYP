// Generated by gencpp from file swarmtal_msgs/drone_commander_state.msg
// DO NOT EDIT!


#ifndef SWARMTAL_MSGS_MESSAGE_DRONE_COMMANDER_STATE_H
#define SWARMTAL_MSGS_MESSAGE_DRONE_COMMANDER_STATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <geometry_msgs/Point.h>
#include <geometry_msgs/Point.h>
#include <swarmtal_msgs/drone_pos_ctrl_cmd.h>
#include <sensor_msgs/Imu.h>

namespace swarmtal_msgs
{
template <class ContainerAllocator>
struct drone_commander_state_
{
  typedef drone_commander_state_<ContainerAllocator> Type;

  drone_commander_state_()
    : ctrl_input_state(0)
    , flight_status(0)
    , control_auth(0)
    , takeoff_target_height(0.0)
    , takeoff_velocity(0.0)
    , vo_latency(0.0)
    , landing_mode(0)
    , landing_velocity(0.0)
    , commander_ctrl_mode(0)
    , bat_vol(0.0)
    , bat_remain(0.0)
    , is_armed(false)
    , rc_valid(false)
    , onboard_cmd_valid(false)
    , vo_valid(false)
    , djisdk_valid(false)
    , pos()
    , vel()
    , yaw(0.0)
    , ctrl_cmd()
    , imu_data()  {
    }
  drone_commander_state_(const ContainerAllocator& _alloc)
    : ctrl_input_state(0)
    , flight_status(0)
    , control_auth(0)
    , takeoff_target_height(0.0)
    , takeoff_velocity(0.0)
    , vo_latency(0.0)
    , landing_mode(0)
    , landing_velocity(0.0)
    , commander_ctrl_mode(0)
    , bat_vol(0.0)
    , bat_remain(0.0)
    , is_armed(false)
    , rc_valid(false)
    , onboard_cmd_valid(false)
    , vo_valid(false)
    , djisdk_valid(false)
    , pos(_alloc)
    , vel(_alloc)
    , yaw(0.0)
    , ctrl_cmd(_alloc)
    , imu_data(_alloc)  {
  (void)_alloc;
    }



   typedef uint32_t _ctrl_input_state_type;
  _ctrl_input_state_type ctrl_input_state;

   typedef uint32_t _flight_status_type;
  _flight_status_type flight_status;

   typedef uint32_t _control_auth_type;
  _control_auth_type control_auth;

   typedef double _takeoff_target_height_type;
  _takeoff_target_height_type takeoff_target_height;

   typedef double _takeoff_velocity_type;
  _takeoff_velocity_type takeoff_velocity;

   typedef float _vo_latency_type;
  _vo_latency_type vo_latency;

   typedef uint32_t _landing_mode_type;
  _landing_mode_type landing_mode;

   typedef double _landing_velocity_type;
  _landing_velocity_type landing_velocity;

   typedef uint32_t _commander_ctrl_mode_type;
  _commander_ctrl_mode_type commander_ctrl_mode;

   typedef float _bat_vol_type;
  _bat_vol_type bat_vol;

   typedef float _bat_remain_type;
  _bat_remain_type bat_remain;

   typedef uint8_t _is_armed_type;
  _is_armed_type is_armed;

   typedef uint8_t _rc_valid_type;
  _rc_valid_type rc_valid;

   typedef uint8_t _onboard_cmd_valid_type;
  _onboard_cmd_valid_type onboard_cmd_valid;

   typedef uint8_t _vo_valid_type;
  _vo_valid_type vo_valid;

   typedef uint8_t _djisdk_valid_type;
  _djisdk_valid_type djisdk_valid;

   typedef  ::geometry_msgs::Point_<ContainerAllocator>  _pos_type;
  _pos_type pos;

   typedef  ::geometry_msgs::Point_<ContainerAllocator>  _vel_type;
  _vel_type vel;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef  ::swarmtal_msgs::drone_pos_ctrl_cmd_<ContainerAllocator>  _ctrl_cmd_type;
  _ctrl_cmd_type ctrl_cmd;

   typedef  ::sensor_msgs::Imu_<ContainerAllocator>  _imu_data_type;
  _imu_data_type imu_data;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(CTRL_INPUT_NONE)
  #undef CTRL_INPUT_NONE
#endif
#if defined(_WIN32) && defined(CTRL_INPUT_RC)
  #undef CTRL_INPUT_RC
#endif
#if defined(_WIN32) && defined(CTRL_INPUT_ONBOARD)
  #undef CTRL_INPUT_ONBOARD
#endif
#if defined(_WIN32) && defined(FLIGHT_STATUS_IDLE)
  #undef FLIGHT_STATUS_IDLE
#endif
#if defined(_WIN32) && defined(FLIGHT_STATUS_ARMED)
  #undef FLIGHT_STATUS_ARMED
#endif
#if defined(_WIN32) && defined(FLIGHT_STATUS_IN_AIR)
  #undef FLIGHT_STATUS_IN_AIR
#endif
#if defined(_WIN32) && defined(FLIGHT_STATUS_CRASHED)
  #undef FLIGHT_STATUS_CRASHED
#endif
#if defined(_WIN32) && defined(CTRL_AUTH_RC)
  #undef CTRL_AUTH_RC
#endif
#if defined(_WIN32) && defined(CTRL_AUTH_APP)
  #undef CTRL_AUTH_APP
#endif
#if defined(_WIN32) && defined(CTRL_AUTH_THIS)
  #undef CTRL_AUTH_THIS
#endif
#if defined(_WIN32) && defined(LANDING_MODE_XYVEL)
  #undef LANDING_MODE_XYVEL
#endif
#if defined(_WIN32) && defined(LANDING_MODE_ATT)
  #undef LANDING_MODE_ATT
#endif
#if defined(_WIN32) && defined(CTRL_MODE_IDLE)
  #undef CTRL_MODE_IDLE
#endif
#if defined(_WIN32) && defined(CTRL_MODE_TAKEOFF)
  #undef CTRL_MODE_TAKEOFF
#endif
#if defined(_WIN32) && defined(CTRL_MODE_LANDING)
  #undef CTRL_MODE_LANDING
#endif
#if defined(_WIN32) && defined(CTRL_MODE_HOVER)
  #undef CTRL_MODE_HOVER
#endif
#if defined(_WIN32) && defined(CTRL_MODE_POSVEL)
  #undef CTRL_MODE_POSVEL
#endif
#if defined(_WIN32) && defined(CTRL_MODE_ATT)
  #undef CTRL_MODE_ATT
#endif
#if defined(_WIN32) && defined(CTRL_MODE_MISSION)
  #undef CTRL_MODE_MISSION
#endif

  enum {
    CTRL_INPUT_NONE = 0u,
    CTRL_INPUT_RC = 1u,
    CTRL_INPUT_ONBOARD = 2u,
    FLIGHT_STATUS_IDLE = 0u,
    FLIGHT_STATUS_ARMED = 1u,
    FLIGHT_STATUS_IN_AIR = 2u,
    FLIGHT_STATUS_CRASHED = 3u,
    CTRL_AUTH_RC = 0u,
    CTRL_AUTH_APP = 1u,
    CTRL_AUTH_THIS = 2u,
    LANDING_MODE_XYVEL = 0u,
    LANDING_MODE_ATT = 1u,
    CTRL_MODE_IDLE = 0u,
    CTRL_MODE_TAKEOFF = 1u,
    CTRL_MODE_LANDING = 2u,
    CTRL_MODE_HOVER = 3u,
    CTRL_MODE_POSVEL = 4u,
    CTRL_MODE_ATT = 5u,
    CTRL_MODE_MISSION = 6u,
  };


  typedef boost::shared_ptr< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> const> ConstPtr;

}; // struct drone_commander_state_

typedef ::swarmtal_msgs::drone_commander_state_<std::allocator<void> > drone_commander_state;

typedef boost::shared_ptr< ::swarmtal_msgs::drone_commander_state > drone_commander_statePtr;
typedef boost::shared_ptr< ::swarmtal_msgs::drone_commander_state const> drone_commander_stateConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator1> & lhs, const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator2> & rhs)
{
  return lhs.ctrl_input_state == rhs.ctrl_input_state &&
    lhs.flight_status == rhs.flight_status &&
    lhs.control_auth == rhs.control_auth &&
    lhs.takeoff_target_height == rhs.takeoff_target_height &&
    lhs.takeoff_velocity == rhs.takeoff_velocity &&
    lhs.vo_latency == rhs.vo_latency &&
    lhs.landing_mode == rhs.landing_mode &&
    lhs.landing_velocity == rhs.landing_velocity &&
    lhs.commander_ctrl_mode == rhs.commander_ctrl_mode &&
    lhs.bat_vol == rhs.bat_vol &&
    lhs.bat_remain == rhs.bat_remain &&
    lhs.is_armed == rhs.is_armed &&
    lhs.rc_valid == rhs.rc_valid &&
    lhs.onboard_cmd_valid == rhs.onboard_cmd_valid &&
    lhs.vo_valid == rhs.vo_valid &&
    lhs.djisdk_valid == rhs.djisdk_valid &&
    lhs.pos == rhs.pos &&
    lhs.vel == rhs.vel &&
    lhs.yaw == rhs.yaw &&
    lhs.ctrl_cmd == rhs.ctrl_cmd &&
    lhs.imu_data == rhs.imu_data;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator1> & lhs, const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace swarmtal_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "95ace68b12ed603a8645498808e5a9bb";
  }

  static const char* value(const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x95ace68b12ed603aULL;
  static const uint64_t static_value2 = 0x8645498808e5a9bbULL;
};

template<class ContainerAllocator>
struct DataType< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "swarmtal_msgs/drone_commander_state";
  }

  static const char* value(const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint32 CTRL_INPUT_NONE=0\n"
"uint32 CTRL_INPUT_RC=1\n"
"uint32 CTRL_INPUT_ONBOARD=2\n"
"\n"
"uint32 ctrl_input_state\n"
"\n"
"\n"
"uint32 FLIGHT_STATUS_IDLE=0 # Motor Stopped, on ground\n"
"uint32 FLIGHT_STATUS_ARMED=1 # Armed, on ground\n"
"uint32 FLIGHT_STATUS_IN_AIR=2 #Armed Inair\n"
"uint32 FLIGHT_STATUS_CRASHED=3 # Crashed, Armed\n"
"\n"
"uint32 flight_status\n"
"\n"
"uint32 CTRL_AUTH_RC = 0\n"
"uint32 CTRL_AUTH_APP = 1\n"
"uint32 CTRL_AUTH_THIS = 2\n"
"\n"
"uint32 control_auth\n"
"\n"
"float64 takeoff_target_height\n"
"float64 takeoff_velocity\n"
"\n"
"float32 vo_latency\n"
"#0 vo landing\n"
"#1 zero attitude landing\n"
"\n"
"uint32 LANDING_MODE_XYVEL = 0\n"
"uint32 LANDING_MODE_ATT = 1\n"
"\n"
"uint32 landing_mode\n"
"float64 landing_velocity\n"
"\n"
"uint32 CTRL_MODE_IDLE=0\n"
"uint32 CTRL_MODE_TAKEOFF=1\n"
"uint32 CTRL_MODE_LANDING=2\n"
"uint32 CTRL_MODE_HOVER=3\n"
"uint32 CTRL_MODE_POSVEL=4\n"
"uint32 CTRL_MODE_ATT=5\n"
"uint32 CTRL_MODE_MISSION=6\n"
"\n"
"uint32 commander_ctrl_mode\n"
"\n"
"float32 bat_vol\n"
"float32 bat_remain\n"
"\n"
"bool is_armed\n"
"bool rc_valid\n"
"bool onboard_cmd_valid\n"
"bool vo_valid\n"
"bool djisdk_valid\n"
"\n"
"geometry_msgs/Point pos\n"
"geometry_msgs/Point vel\n"
"float64 yaw\n"
"\n"
"drone_pos_ctrl_cmd ctrl_cmd\n"
"\n"
"sensor_msgs/Imu imu_data\n"
"================================================================================\n"
"MSG: geometry_msgs/Point\n"
"# This contains the position of a point in free space\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
"\n"
"================================================================================\n"
"MSG: swarmtal_msgs/drone_pos_ctrl_cmd\n"
"uint32 CTRL_CMD_IDLE_MODE = 0\n"
"uint32 CTRL_CMD_VEL_MODE  = 1\n"
"uint32 CTRL_CMD_POS_MODE  = 2\n"
"uint32 CTRL_CMD_ATT_THRUST_MODE  = 3\n"
"uint32 CTRL_CMD_ATT_VELZ_MODE  = 4\n"
"\n"
"uint32 ctrl_mode\n"
"\n"
"geometry_msgs/Vector3 pos_sp\n"
"geometry_msgs/Vector3 vel_sp\n"
"geometry_msgs/Vector3 acc_sp\n"
"geometry_msgs/Quaternion att_sp\n"
"float64 yaw_sp\n"
"float64 z_sp\n"
"\n"
"bool use_fc_yaw\n"
"\n"
"geometry_msgs/Vector3 max_vel\n"
"================================================================================\n"
"MSG: geometry_msgs/Vector3\n"
"# This represents a vector in free space. \n"
"# It is only meant to represent a direction. Therefore, it does not\n"
"# make sense to apply a translation to it (e.g., when applying a \n"
"# generic rigid transformation to a Vector3, tf2 will only apply the\n"
"# rotation). If you want your data to be translatable too, use the\n"
"# geometry_msgs/Point message instead.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
"================================================================================\n"
"MSG: geometry_msgs/Quaternion\n"
"# This represents an orientation in free space in quaternion form.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
"float64 w\n"
"\n"
"================================================================================\n"
"MSG: sensor_msgs/Imu\n"
"# This is a message to hold data from an IMU (Inertial Measurement Unit)\n"
"#\n"
"# Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec\n"
"#\n"
"# If the covariance of the measurement is known, it should be filled in (if all you know is the \n"
"# variance of each measurement, e.g. from the datasheet, just put those along the diagonal)\n"
"# A covariance matrix of all zeros will be interpreted as \"covariance unknown\", and to use the\n"
"# data a covariance will have to be assumed or gotten from some other source\n"
"#\n"
"# If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation \n"
"# estimate), please set element 0 of the associated covariance matrix to -1\n"
"# If you are interpreting this message, please check for a value of -1 in the first element of each \n"
"# covariance matrix, and disregard the associated estimate.\n"
"\n"
"Header header\n"
"\n"
"geometry_msgs/Quaternion orientation\n"
"float64[9] orientation_covariance # Row major about x, y, z axes\n"
"\n"
"geometry_msgs/Vector3 angular_velocity\n"
"float64[9] angular_velocity_covariance # Row major about x, y, z axes\n"
"\n"
"geometry_msgs/Vector3 linear_acceleration\n"
"float64[9] linear_acceleration_covariance # Row major x, y z \n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.ctrl_input_state);
      stream.next(m.flight_status);
      stream.next(m.control_auth);
      stream.next(m.takeoff_target_height);
      stream.next(m.takeoff_velocity);
      stream.next(m.vo_latency);
      stream.next(m.landing_mode);
      stream.next(m.landing_velocity);
      stream.next(m.commander_ctrl_mode);
      stream.next(m.bat_vol);
      stream.next(m.bat_remain);
      stream.next(m.is_armed);
      stream.next(m.rc_valid);
      stream.next(m.onboard_cmd_valid);
      stream.next(m.vo_valid);
      stream.next(m.djisdk_valid);
      stream.next(m.pos);
      stream.next(m.vel);
      stream.next(m.yaw);
      stream.next(m.ctrl_cmd);
      stream.next(m.imu_data);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct drone_commander_state_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::swarmtal_msgs::drone_commander_state_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::swarmtal_msgs::drone_commander_state_<ContainerAllocator>& v)
  {
    s << indent << "ctrl_input_state: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ctrl_input_state);
    s << indent << "flight_status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.flight_status);
    s << indent << "control_auth: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.control_auth);
    s << indent << "takeoff_target_height: ";
    Printer<double>::stream(s, indent + "  ", v.takeoff_target_height);
    s << indent << "takeoff_velocity: ";
    Printer<double>::stream(s, indent + "  ", v.takeoff_velocity);
    s << indent << "vo_latency: ";
    Printer<float>::stream(s, indent + "  ", v.vo_latency);
    s << indent << "landing_mode: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.landing_mode);
    s << indent << "landing_velocity: ";
    Printer<double>::stream(s, indent + "  ", v.landing_velocity);
    s << indent << "commander_ctrl_mode: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.commander_ctrl_mode);
    s << indent << "bat_vol: ";
    Printer<float>::stream(s, indent + "  ", v.bat_vol);
    s << indent << "bat_remain: ";
    Printer<float>::stream(s, indent + "  ", v.bat_remain);
    s << indent << "is_armed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_armed);
    s << indent << "rc_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rc_valid);
    s << indent << "onboard_cmd_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.onboard_cmd_valid);
    s << indent << "vo_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vo_valid);
    s << indent << "djisdk_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.djisdk_valid);
    s << indent << "pos: ";
    s << std::endl;
    Printer< ::geometry_msgs::Point_<ContainerAllocator> >::stream(s, indent + "  ", v.pos);
    s << indent << "vel: ";
    s << std::endl;
    Printer< ::geometry_msgs::Point_<ContainerAllocator> >::stream(s, indent + "  ", v.vel);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "ctrl_cmd: ";
    s << std::endl;
    Printer< ::swarmtal_msgs::drone_pos_ctrl_cmd_<ContainerAllocator> >::stream(s, indent + "  ", v.ctrl_cmd);
    s << indent << "imu_data: ";
    s << std::endl;
    Printer< ::sensor_msgs::Imu_<ContainerAllocator> >::stream(s, indent + "  ", v.imu_data);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SWARMTAL_MSGS_MESSAGE_DRONE_COMMANDER_STATE_H
